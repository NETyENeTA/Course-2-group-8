
using System;
using System.Threading.Tasks;



namespace Testy
{



    class Program
    {

        static void Main(string[] args)
        {
            int[] way = [4, 2, 0, 1, 2, 3, 1, 1, 0]; // сам путь.

            int step = 0; // шаги в перёд.
            int totalSteps = 0; // сколько шагов сделали.

            bool isGameOver = false; // для вывода сообщение проигрыша или выигрыша.


            for (int i = 0; i < way.Length; i += step) // пройдемся по массиву, step делает проход к следуюшему "лучшему" шагу
                                                       // (то есть 1-ый шаг это: int[] way = [4, 2, 0, 1, 2 ...], то step = 4 так как нам нужен самый правый и большой эл-т).
            {
                if (way[i] == 0 && i != way.Length - 1) { isGameOver = true; break; } // если текущий елемент == 0 и это не посдедный эл-т
                                                                                      // (если конец это посдедный эл-т) , то Game Over.

                if (i + way[i] >= way.Length - 1) { totalSteps++; break; } // если мы смотрим на конец списка, то его не нудно проверять, так как мы шагаем дальше,
                                                                           // чем длина массива.
                                                                           // Пример [4, 2, 0, 1, 2, 3, 1, 1, 0] путь.
                                                                           //         a  b  c  d  e  f  g  h  l -> индексы, но буквенные.
                                                                           // a -> e -> f -> нет смысла проверять так как вылазием из массива.


                int[] tempWeys = way[(i + 1)..(i + way[i] + 1)]; // создаём временной подмассив. Это массив, где мы ищем "идеальный" или "лучший" шаг.
                                                                 // Пример [4, 2, 0, 1, 2, 3, 1, 1, 0] путь.
                                                                 //         a  b  c  d  e  f  g  h  l -> индексы, но буквенные.
                                                                 // a=4 То создаётся подмассив [2, 0, 1, 2] (или [b, c, d, e])

                for (int j = way[i]; j > 0; j--) // пройдемся по подмассиву
                {
                    if (i + j >= way.Length) continue; // проверим, что не вышли из массива
                    if (way[i + j] == tempWeys.Max()) { step = j; break; } // Насамом деле мы проходим по массиву, но по индексам мы ток чекаем подмассив.
                                                                           // В этом  цикле мы и ищем "лучший" шаг, он самый правый и большой эл-т подмассива
                                                                           // Пример [4, 2, 0, 1, 2, 3, 1, 1, 0] путь.
                                                                           //         a  b  c  d  E  f  g  h  l -> индексы, но буквенные.
                                                                           // подмассив [2, 0, 1, 2] => последня 2-ка (или E) она нам и нужна и она удачлива
                }

                totalSteps++; //просто добовляем кол-во шагов)
            }

            // просто выводим ответ через тернарный оператор

            Console.WriteLine(isGameOver ? "No! You can't go, you reached a zero..." : $"YES! You can, total steps:{totalSteps}");
        }

    }
}